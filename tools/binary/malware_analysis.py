#!/usr/bin/env python3
"""Malware Analysis Tools - Simple, focused implementations"""

import subprocess
import json
import os
from typing import Dict, Any, List, Optional

def cuckoo_sandbox_submit(sample_path: str, timeout: int = 120) -> Dict[str, Any]:
    """Automated malware analysis sandbox"""
    try:
        cmd = ['cuckoo', 'submit', '--timeout', str(timeout), sample_path]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

        # Parse task ID from output
        task_id = None
        for line in result.stdout.split('\n'):
            if 'Task ID' in line or 'added as task' in line:
                import re
                match = re.search(r'\d+', line)
                if match:
                    task_id = match.group()

        return {"success": result.returncode == 0, "task_id": task_id, "sample": sample_path, "tool": "cuckoo-sandbox"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def yara_scan(target_path: str, rules_path: Optional[str] = None) -> Dict[str, Any]:
    """YARA pattern matching for malware detection"""
    try:
        if rules_path:
            cmd = ['yara', rules_path, target_path]
        else:
            # Use default rules if available
            default_rules = '/usr/share/yara/rules/malware.yar'
            if os.path.exists(default_rules):
                cmd = ['yara', default_rules, target_path]
            else:
                cmd = ['yara', '-r', '/usr/share/yara/', target_path]

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)

        # Parse matches
        matches = []
        for line in result.stdout.split('\n'):
            if line.strip():
                matches.append(line.strip())

        return {"success": result.returncode == 0, "matches": matches, "count": len(matches), "tool": "yara"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def pestudio_analyze(binary_path: str) -> Dict[str, Any]:
    """Static malware analysis with PEStudio"""
    try:
        # PEStudio is Windows-only, use fallback analysis
        import pefile

        pe = pefile.PE(binary_path)

        analysis = {
            "imports": [],
            "exports": [],
            "sections": [],
            "suspicious_strings": []
        }

        # Extract imports
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll = entry.dll.decode('utf-8') if isinstance(entry.dll, bytes) else entry.dll
                analysis["imports"].append(dll)

        # Extract exports
        if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
            for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                name = exp.name.decode('utf-8') if exp.name else ''
                if name:
                    analysis["exports"].append(name)

        # Extract sections
        for section in pe.sections:
            analysis["sections"].append({
                "name": section.Name.decode('utf-8').strip('\x00'),
                "virtual_size": section.Misc_VirtualSize,
                "entropy": section.get_entropy()
            })

        return {"success": True, "analysis": analysis, "tool": "pestudio"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def strings_extended(binary_path: str, min_length: int = 4, encoding: str = "all") -> Dict[str, Any]:
    """Enhanced string extraction"""
    try:
        encodings = {
            "ascii": ['-e', 's'],
            "unicode": ['-e', 'l'],
            "all": ['-e', 's', '-e', 'l']
        }

        cmd = ['strings', '-n', str(min_length)] + encodings.get(encoding, ['-e', 's']) + [binary_path]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)

        # Extract and categorize strings
        strings_list = result.stdout.split('\n')
        categorized = {
            "urls": [],
            "ips": [],
            "emails": [],
            "registry_keys": [],
            "file_paths": [],
            "other": []
        }

        import re
        for s in strings_list:
            if not s.strip():
                continue
            if re.match(r'https?://', s):
                categorized["urls"].append(s)
            elif re.match(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}', s):
                categorized["ips"].append(s)
            elif '@' in s and '.' in s:
                categorized["emails"].append(s)
            elif 'HKEY_' in s or 'SOFTWARE\\' in s:
                categorized["registry_keys"].append(s)
            elif ':\\' in s or '/' in s and len(s) > 10:
                categorized["file_paths"].append(s)
            else:
                categorized["other"].append(s)

        return {"success": True, "strings": categorized, "total": len(strings_list), "tool": "strings-extended"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def floss_analyze(binary_path: str) -> Dict[str, Any]:
    """FireEye Labs Obfuscated String Solver"""
    try:
        cmd = ['floss', '--json', binary_path]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)

        try:
            floss_output = json.loads(result.stdout)
        except:
            floss_output = {"strings": result.stdout}

        return {"success": result.returncode == 0, "output": floss_output, "tool": "floss"}
    except Exception as e:
        return {"success": False, "error": str(e)}

def hollows_hunter_scan(pid: Optional[int] = None, scan_all: bool = False) -> Dict[str, Any]:
    """Process hollowing and injection detection"""
    try:
        if scan_all:
            cmd = ['hollows_hunter.exe', '/all']
        elif pid:
            cmd = ['hollows_hunter.exe', '/pid', str(pid)]
        else:
            cmd = ['hollows_hunter.exe']

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)

        # Parse detections
        detections = []
        for line in result.stdout.split('\n'):
            if 'suspicious' in line.lower() or 'detected' in line.lower():
                detections.append(line.strip())

        return {"success": result.returncode == 0, "detections": detections, "count": len(detections), "tool": "hollows-hunter"}
    except Exception as e:
        return {"success": False, "error": str(e)}
